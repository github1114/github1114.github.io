
## 모든 객체의 공통 메서드

### 1. equals는 일반 규약을 지켜 재정의하자

- 각 인스턴스가 본질적으로 고유하다.
- 인스턴스의 '논리적 동치성'을 검사할 일이 없다.
- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
- 클래스가 private이거나 package-private이고 equlas 메서드를 호출할 일이 없다.

** 두 객체가 물리적으로 같은가가 아니라 논리적 동치성을 확인해야 하는데, 
상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때 equals를 재정의하자


#### equals 메서드 재정의 시 반드시 따라야 하는 일반 규약.

#### (null이 아닌 모든 참조 값 x,y,z 에 대해서)
#### 1. 반사성 : x.equals(x) == true
#### 2. 대칭성 : if x.equals(y) == true, y.equals(x) == true
#### 3. 추이성 : if x.equals(y) == true and y.equals(z) == true, x.equals(z) == true
#### 4. 일관성 : x.equals(x) 를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
#### 5. null-아님 : x.equals(null) == false

- eqals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응할지 알 수 없다
- 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.
- equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안된다.

#### equals 메서드 구현 단계별 방법

#### 1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
#### 2. instanceof 연산자로 입력이 올바른 타입인지 확인한다.
#### 3. 입력을 올바른 타입으로 형변환한다
#### 4. 입력 객체와 자기 자신의 대응되는 '핵심'필드들이 모두 일치하는지 하나씩 검사한다.

**어노테이션 추가로 구글의 AutoValue 프레임워크를 활용하면 빠르고 간단하게 사람의 실수를 보완할 수 있다.











### 2. equals를 재정의하려거든 hashCode도 재정의하라 

- equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다.


#### equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.

- 위 조항은 hashCode 재정의를 잘못했을 때 크게 문제가 되는 부분이. 즉, 논리적으로 같은 객체는 같은 해시코드를 반환해야한다.
- 성능을 높인갑시고 해시코들르 계산할 때 핵심 필드를 생략해서는 안 된다.
- hashCode가 반환하는 값의 생성 규칙을 API사용자에게 자세히 공표하지 말자. 그래야 클라이언트가 이 값에 의지하지 않게 되고,
추후에 계산 방식을 바꿀 수도 있다.








### 3. toString을 항상 재정의하자

- toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.
- 실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는 게 좋다.
- 포맷을 명시하든 아니든 여러분의 의도는 명확히 밝혀야 한다.
- toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공하자

