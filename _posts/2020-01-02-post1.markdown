
## 객체 생성과 파괴



### 1. 생성자 대신 정적 팩터리 메서드를 고려하자

- 이름을 가질 수 있다.
- 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
- 인스턴스를 통제하여 클래스를 싱글턴으로 만들 수도, 인스턴스화 불가로 만들 수도 있다.
- 불변 값 클래스에서 동치인 인스턴스가 단 하나뿐임을 보장할 수 있다.
- 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
- 반환할 객체의 클래스를 자유롭게 선택할 수 있으므로 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있다.
- 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
- 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.




### 2. 생성자에 매개변수가 많다면 빌더를 고려하자

- 매개변수의 다수가 필수가 아니거나 같은 타입이면 더욱 고려해봐야한다
- 빌더는 점층적 생성자보다 클라이언트단에서 가독성이 좋으며 자바빈즈보다 훨씬 안전하다.



### 3. private 생성자나 열거(enum) 타입으로 싱글턴임을 보증하자

- 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.
- 대부분의 상황에서는 element가 하나뿐인 열거(enum)타입이 싱글턴을 만드는 가장 좋은 방법이다.

### 4. 인스턴스화를 막으려거든 private 생성자를 사용하라 (utility class)

- 추상클래스로 만드는 것으로는 인스턴스화를 막을 수 없다
- private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.

### 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

- 사용하는 자원에 따라 동작이 달라지는 클래스(맞춤법검사 class)에는 static 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.
- 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식으로 구현하자

### 6. 불필요한 객체 생성을 피하자

- String.matches 같은 비싼 객체를 재사용해 성능을 개선한다
- 객체가 생성되는 위치를 찾아내러 박싱된  primitive type 보다는 그보다 작은 primitive type을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자
 
### 7. 다 쓴 객체 참조를 해제하자 (ex. Stack)

- 객체 참조를 null처리하는 일은 예외적인 경우여야 한다
- 캐시 역시 메모리 누수를 일으키는 주범이다
- 리스너 또는 콜백이라 부르는 것들도 메모리 누수를 일으킬 수 있다. 사용한 뒤에 명시적으로 해지해주자

### 8. finalizer와 cleaner 사용을 피하라

- finalizer와 cleaner(객체소멸자)는 일반적으로 불필요하다. 사용에 주의해아한다.

### 9. try-finally보다는 try-with-resource를 사용하라

- 이것에 예외는 없다. 이로인해 코드는 더 분명해지고 예외정보도 훨씬 유용하며 정확하고 쉽게 자원을 회수할 수 있다.
